//
//  Artifact.swift
//  FuzzCheck
//

import Files
import Foundation

/*
 This file is longer than it is worth.

 Basically, it describes how to save the artifacts created by a fuzzer
 to disk. To do so, it needs to know how to construct the artifact
 filename and its content, which are parameterizable by the user.

 For example, a user might wish to save artifacts under the filename
 schema ?kind-?index-?hash and the extension .json, which might result in
 a filename "testFailure-3-fc3daa1056".
 
 Inside an artifact file, a user might wish to include the complexity
 of the test input and its score, but not its hash, etc.
 */

/**
 Description of an Artifact file generated by a command line fuzzer
 It contains the input and maybe some metadata associated to it.
*/
public struct Artifact <Input: Codable> {
    /// The partial name of the artifact file, to be completed by its index.
    let name: ArtifactNameWithoutIndex
    /// The content of the artifact file.
    let content: Content

    public struct Content {
        /// The test input that the artifact file describes
        let input: Input
        /// The features discovered by that test input.
        let features: [CodeCoverageSensor.Feature]?
        /// The score of the input, which can depend on the state
        /// of the fuzzer's input pool at the time the artifact was generated.
        let score: Double?
        let hash: Int?
        let complexity: Double?
        let kind: ArtifactKind?
    }
}

/**
 Describes the structure of the artifact filename and
 which information to include in the artifact file content.
*/
public struct ArtifactSchema {
    public var name: Name
    public var content: Content
    
    /**
     Describes the filename schema of an artifact.
     It consists of a list of “components” and an optional filename extension.
     */
    public struct Name: Hashable {
        /**
         An ArtifactSchema.Name.Component is a part of the artifact filename.
         It can either be a string literal, or space for artifact-specific information.
        */
        public enum Component: Hashable {
            case literal(String)
            case hash
            case complexity
            
            /// Space for a generated unique identifier to make
            /// the artifact filename unique in the file system
            case index
            
            case kind
        }
        public var components: [Component]
        
        /// The file name extension
        public var ext: String?
    }
    
    /**
     Describes the content schema of an artifact file.
     
     It contains a property for each optional piece of information that could
     be included in the artifact file.
    */
    public struct Content {
        public let features: Bool
        public let score: Bool
        public let hash: Bool
        public let complexity: Bool
        public let kind: Bool
    
        public init(features: Bool, score: Bool, hash: Bool, complexity: Bool, kind: Bool) {
           self.features = features
           self.score = score
           self.hash = hash
           self.complexity = complexity
           self.kind = kind
        }
    }
}

extension Artifact.Content {
    init(schema: ArtifactSchema.Content, input: Input, features: [CodeCoverageSensor.Feature]?, score: Double?, hash: Int?, complexity: Double?, kind: ArtifactKind) {
        self.input = input
        self.features = schema.features ? features : nil
        self.score = schema.score ? score : nil
        self.hash = schema.hash ? hash : nil
        self.complexity = schema.complexity ? complexity : nil
        self.kind = schema.kind ? kind : nil
    }
}

/// Information that might be needed to construct the filename of an artifact.
public struct ArtifactNameInfo: Hashable {
    let hash: Int
    let complexity: Double
    let kind: ArtifactKind
}

/// The kind of an artifact
public enum ArtifactKind: String, Codable {
    /// The input did not result in any kind of failure, but may be interesting enough to save.
    case input
    /// The input caused the test function to take too long to executes
    case timeout
    /// The input caused the test function to crash
    case crash
    /// The input caused the test function to fail
    case testFailure
}

/**
 A resolved artifact filename whose only piece of missing information
 is its generated unique identifier (called `index`).
*/
public struct ArtifactNameWithoutIndex: Hashable {
    /// The filename that does not include the index
    let string: String
    /// The range inside `self.string` that should be replaced by the index
    let gapForIndex: Range<String.Index>
    
    func fillGap(with index: Int) -> String {
        var s = string
        s.replaceSubrange(gapForIndex, with: "\(index)")
        return s
    }
    
    /**
     Find an index such that `self.fillGap(with: index)` results in a
     string distinct from those in the given set, and return that string.
    */
    func fillGapToBeUnique(from set: Set<String>) -> String {
        // in practice very few loop iterations will be performed
        for i in 0... {
            let candidate = fillGap(with: i)
            if !set.contains(candidate) { return candidate }
        }
        fatalError()
    }
    
    init(string: String, gapForIndex: Range<String.Index>) {
        self.string = string
        self.gapForIndex = gapForIndex
    }
    
    init(schema: ArtifactSchema.Name, info: ArtifactNameInfo) {
        var name = ""
        var gapForIndex: Range<String.Index>? = nil
        for a in schema.components {
            switch a {
            case .literal(let s):
                name += s
            case .hash:
                name += hexString(info.hash)
            case .complexity:
                name += "\(Int(info.complexity.rounded()))"
            case .kind:
                name += "\(info.kind)"
            case .index:
                gapForIndex = name.endIndex ..< name.endIndex
            }
        }
        if gapForIndex == nil {
            gapForIndex = name.endIndex ..< name.endIndex
        }
        if let ext = schema.ext, !ext.isEmpty {
            name += ".\(ext)"
        }
        self.init(string: name, gapForIndex: gapForIndex!)
    }
}

extension ArtifactSchema.Name.Component: CustomStringConvertible {
    public var description: String {
        switch self {
        case .literal(let s):
            return s
        case .hash:
            return "?hash"
        case .complexity:
            return "?complexity"
        case .index:
            return "?index"
        case .kind:
            return "?kind"
        }
    
    }
}

extension ArtifactSchema.Name.Component {
    /**
     Consume a single artifact schema name component from the given substring.
    */
    static func read(from s: inout Substring) -> ArtifactSchema.Name.Component? {
        guard let first = s.first else {
            return nil
        }
        let specials: [ArtifactSchema.Name.Component] = [.hash, .complexity, .index, .kind]
        for special in specials {
            if s.starts(with: special.description) {
                defer { s = s.dropFirst(special.description.count) }
                return special
            }
        }
        // No matches. Return a simple string
        guard let nextQMark = s.dropFirst().firstIndex(of: "?") else {
            defer { s = s[s.endIndex ..< s.endIndex] }
            return .literal(String(s))
        }
        defer { s = s.suffix(from: nextQMark) }
        return .literal(String(s.prefix(upTo: nextQMark)))
    }
    
    /**
     Parses a list of artifact name schema from the given string.
     
     ## Syntax
     A question mark followed by the name of a known component result in a non-literal component.
     Everything else is a literal.
     
     ## Example
     
     "`?hash-?complexity and ?whatever`" is parsed as
     - `.hash`
     - `.literal("-")`
     - `.complexity`
     - `.literal("and ?whatever")`
     */
    public static func read(from s: String) -> [ArtifactSchema.Name.Component] {
        var subs = Substring(s)
        var res: [ArtifactSchema.Name.Component] = []
        while let a = read(from: &subs) {
            res.append(a)
        }
        return res
    }
}

extension Artifact.Content: Codable {
    enum CodingKey: Swift.CodingKey {
        case input
        case complexity
        case hash
        case score
        case features
        case kind
    }
    
    public func encode(to encoder: Encoder) throws {
        if self.complexity == nil, self.score == nil, self.hash == nil, self.kind == nil, self.features == nil {
            try input.encode(to: encoder)
        } else {
            var container = encoder.container(keyedBy: CodingKey.self)
            try container.encode(input, forKey: .input)
            try container.encodeIfPresent(complexity, forKey: .complexity)
            try container.encodeIfPresent(score, forKey: .score)
            try container.encodeIfPresent(hash, forKey: .hash)
            try container.encodeIfPresent(kind, forKey: .kind)
            try container.encodeIfPresent(features, forKey: .features)
        }
    }
    public init(from decoder: Decoder) throws {
        if let input = try? Input(from: decoder) {
            self.input = input
            self.complexity = nil
            self.score = nil
            self.hash = nil
            self.features = nil
            self.kind = nil
        } else {
            let container = try decoder.container(keyedBy: CodingKey.self)
            self.input = try container.decode(Input.self, forKey: .input)
            self.complexity = try container.decodeIfPresent(Double.self, forKey: .complexity)
            self.score = try container.decodeIfPresent(Double.self, forKey: .score)
            self.hash = try container.decodeIfPresent(Int.self, forKey: .hash)
            self.features = try container.decodeIfPresent(Array<CodeCoverageSensor.Feature>.self, forKey: .features)
            self.kind = try container.decodeIfPresent(ArtifactKind.self, forKey: .kind)
        }
    }
}
